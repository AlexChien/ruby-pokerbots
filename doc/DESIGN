Components of a Poker Bot
-------------------------

INPUT (Constructing the complete model of the table):
- On MacOSX, can we read a log file?
- Can we screen scrape and OCR
- Must we hook into the application and inject a new shared library?

Input. The input to the system is the poker client software itself, including all its windows, log files, and hand histories, as well as internal (often private) state maintained by the running executable. The goal of the input stage is to interrogate the poker client and produce an accurate model of the table state - your hole cards, names and stack sizes of your opponents, current bets, and so forth.

My Plan:
Hook into the log writer.  We will get the table state in real time. No screen scraping required

PROCESSING:
1. Analyze the table state
2. Make a decision to call, bet, raise, fold or check

Processing. The processing stage runs independently of the other two stages. It's job is to take the table model assembled during the Input phase, and figure out whether to fold, check, bet, raise, or call. That's it. The code that performs this analysis should (ideally) know nothing about screen scraping or interrogating other applications. All it knows is how to take an abstract model of a poker table (probably expressed as some sort of PokerTable class) and determine which betting action to make.

OUTPUT:
- Simulate human input by clicking proper button, set the bet amount, etc.

Output. Once the processing stage has made a decision, the Output stage takes over. It's tasked with clicking the correct buttons on the screen, or simulating whatever user input is necessary in order to actually make the action occur on a given poker site/client.

Use Quickeys to automate the program
Find a way to run quickeys from the command line

DATA MINING:
Using historical data sets, each player will be ranked and categorized.  This will allow the bot to make decisions on the 'emotional' state and history of the other player.

TECHNOLOGY:
Most of this will prototyped in Ruby. The real bot and analytics software will be written in Haskell because correctness is required when writing financial software. We will use the type system to create an application that can be reasoned about and proven to be correct.

